export const meta = {
  title: "Mocking Functions and Modules with Jest",
  lang: "EN",
  category: "DEV",
  lastModified: "",
}

Jest has **lots** of mocking features. For a long time I've been using only a small subset of them, but with experience I was able to gain a deeper understanding of these features. Now I want to share that knowledge with you because it has been incredibly useful to me.

This can be an intimidating area for beginners, especially because at the time of this writing the Jest documentation on this subject is a bit spotty. Add to that the fact that the term "mock" is ambiguous; it can refer to functions, modules, servers etc. I would like to help you get familiar not only with mocking features in Jest, but these testing concepts in general.

## Functions

Mock functions, are powerful and have many purposes--we can create new dummy functions, spy on existing functions, temporarily change their behavior, pass them around... usually in order to eventually make assertions on them, directly or indirectly.

### Spying

Let's start with the most basic example. I assume you already know [how to set up Jest](https://jestjs.io/docs/en/getting-started)? Good. Let's open a test file:

```js
const fn = jest.fn()
```

This is a dummy function. We can call it, but nothing seems to happen.

```js
fn() // nothing...?
fn({ meaningOfLife: 42 }) // still nothing
console.log(fn()) // undefined
```

However, if we inspect the function itself, we'll notice that it's no ordinary function:

```js
console.log(fn)
// { [Function: mockConstructor]
//   _isMockFunction: true,
//   getMockImplementation: [Function],
//   mock: [Getter/Setter],
//   ...
```

For example, let's inspect its `mock` property:

```js
console.log(fn.mock.calls)
// [ [], [ { meaningOfLife: 42 } ], [] ]
```

Looks familiar? It appears that the mock function has been recording our calls! Don't panic, not phone calls, just function calls. This means that we can make assertions on this function, but instead of making assertions on the `mock` property directly, we can use special Jest matchers for mock functions:

```js
test('mock function has been called with the meaning of life', () => {
  const fn = jest.fn()
  fn(42)
  expect(fn).toHaveBeenCalledWith(42)
})
```

But this test is silly, we already know that the function will be called with `42` because _we_ called it within the test itself. Mock functions are mostly useful for passing to the source code that we're testing, then we expect that code to call it in a certain way. For example:

```js
const MontyPython = require('./monty-python')

// ok, I wasn't planning on continuing with this
// Monty Python reference, but I guess we're doing this ðŸ˜„

describe('MontyPython', () => {
  describe('callFnWithTheMeaningOfLife', () => {
    it('calls given function with the meaning of life', () => {
      const montyPython = new MontyPython()
      const fn = jest.fn()
      montyPython.callFnWithTheMeaningOfLife(fn)
      expect(fn).toHaveBeenCalledWith(42)
    })
  })
})
```

But what if meaning of life isn't 42? Life is never that simple, things often don't happen for a reason, they're just random, and it's on us to try to make the best of it. â¤ï¸

Now that we had this life-changing epiphany, let's create a new method which returns a more honest answer, i.e. `Math.random()`:

```js
module.exports = class MontyPython {
  getTheMeaningOfLife() {
    return Math.random() * 100
  }
}
```

That's more like it. In real life you rarely get a clean 42, usually you get something like 19.513179535940452 and you have to roll with it.

Now let's adjust our test. Now we want to check whether `Math.random` has been called. We can't just replace `Math.random` with a mock function because we want to preserve its functionality, instead we can spy on it using `jest.spyOn`, which wraps it in a mock function and returns it so we can track it:

```js
const MontyPython = require('./monty-python')

describe('MontyPython', () => {
  describe('getTheMeaningOfLife', () => {
    it('reveals the cold hard truth about life', () => {
      const montyPython = new MontyPython()
      const mathRandomSpy = jest.spyOn(Math, 'random')
      montyPython.getTheMeaningOfLife()
      expect(mathRandomSpy).toHaveBeenCalled()
      mathRandomSpy.restore()
    })
  })
})
```

Here `Math.random` does its thing, we're not altering its functionality, we're only temporarily wrapping it in a mock function in order to make assertions on it. Then at the end of the test we're removing the wrapper because we no longer need it.

### Altering behavior

Keep in mind that testing is about _purpose_, we'll usually want to test overall functionality, not details like whether built-ins like `Math.random` were called. To do this we'll probably want to change `Math.random`'s behavior in order to be able to test a larger piece of functionality. This is where the `mockImplementation` method comes in.

Let's say that the head of the [Ministry of Silly Walks](https://youtu.be/KCrQu0VTUBs) wanted to add a method for plotting their walking pattern as an array of steps using left and right legs:

```js
module.exports = class MontyPython {
  getSillyWalk(numberOfSteps) {
    const steps = []
    for (let i = 0; i < numberOfSteps; i++) {
      if (steps[steps.length - 1] !== 'left') {
        steps.push('left')
      } else {
        steps.push('right')
      }
    }
    // shuffle
    return steps.sort(() => 0.5 - Math.random())
  }
}
```


We would like to test this walk using Jest snapshots, but since it's random our tests will fail. We can't test whether the generated walk is in fact silly, we can only test whether it's technically a walk, meaning that it consists of a series of steps for each leg. To do this we'll alter the behavior of `Math.random` using the `mockImplementation` method to always return `0.5` in order to prevent shuffling the array (if the `sort` method returns `0`, order is preserved):

```js
const MontyPython = require('./monty-python')

describe('MontyPython', () => {
  describe('getSillyWalk', () => {
    it('returns a series of steps for each leg', () => {
      const montyPython = new MontyPython()
      const mathRandomSpy = jest.spyOn(Math, 'random')
      mathRandomSpy.mockImplementation(() => 0.5)
      expect(montyPython.getSillyWalk(6)).toMatchSnapshot()
      mathRandomSpy.restore()
    })
  })
})
```

Now when we run our tests, the following deterministic snapshot will be saved:

```
exports[`MontyPython getSillyWalk returns a series of steps for each leg 1`] = `
Array [
  "left",
  "right",
  "left",
  "right",
  "left",
  "right",
]
`;
```

Notice that we didn't make assertions on the spy itself, we just temporarily altered `Math.random`'s behavior so we can make a predictable assertion on the code that it was _affecting_.

Now, since our codebase is split across files, let's start exploring mocking in the context of _modules_.

## Modules

Whether we're testing server or browser code, both of these are using a _module system_. We can take advantage of this by mocking certain dependencies during testing.

Same as with our `Math.random` example, we often don't want some of our modules to do what they normally do. For example, we don't want to make an actual API request, instead we want to mock that implementation in a way that will make our code work without unwanted functionality.

There are three types of mocking modules. Let's start from local to global:

### Mocking per test

Sometimes you want to implement a certain modules differently multiple times within the same file. In this case you should use `jest.doMock` followed by requiring affected modules.

```js
describe('MontyPython', () => {
  describe('getSillyWalk', () => {
    it('returns a series of steps for each leg', () => {
      jest.doMock('./monty-python', () => {
        return class MontyPython {
          getSillyWalk() {
            return [
              'left', 'right',
              'left', 'right',
              'left', 'right',
            ]
          }
        }
      })
      const MontyPython = require('./monty-python')
      const montyPython = new MontyPython()
      expect(montyPython.getSillyWalk(6)).toMatchSnapshot()
      jest.resetModules()
    })
  })
})
```

To prevent tests from affecting each other, make sure to clean up by call `jest.resetModules`. I usually put this in `afterEach`, just so I don't have to always remember to do it, just like `cleanup` in react-testing-library.

### Mocking per file

While `jest.doMock` can also be used on a per file basis, I recommend using the top-level `jest.mock` instead. Use it when you need the same mocked implementation across multiple tests in the same file.

This is a special utility that gets hoisted to the top, before all `import` statements and `require` calls.

```js
const MontyPython = require('./monty-python')

jest.mock('./monty-python', () => {
  return class MontyPython {
    // mocked implementation
  }
})
```

â˜ï¸ The code above actually runs in the reverse order:

```js
jest.mock('./monty-python', () => {
  return class MontyPython {
    // mocked implementation
  }
})

const MontyPython = require('./monty-python')
```

So the imported `MontyPython` class will be the one you provided as mocked implementation (a.k.a. factory) in the `jest.mock` call. Keep this in mind to avoid unexpected behavior. Sometimes errors will remind you about this, e.g. if you try to do funny business like this:

```js
const { meaningOfLife } = require('./consts')

jest.mock('./monty-python', () => {
  return class MontyPython {
    getTheMeaningOfLife() {
      return meaningOfLife
    }
  }
})
```

Jest will throw an error and explaning why this won't work:

```
babel-plugin-jest-hoist: The module factory of `jest.mock()` is not allowed to reference any out-of-scope variables.
Invalid variable access: meaningOfLife
Whitelisted objects: Array, ArrayBuffer, Boolean, (...)
Note: This is a precaution to guard against uninitialized mock variables. If it is ensured that the mock is required lazily, variable names prefixed with `mock` (case insensitive) are permitted.
```

Other than this caveat, `jest.mock` is pretty much the same as `jest.doMock`, with obvious difference that the scope is now the whole file, not a single test. Also, you don't need to reset modules because they are being reset automatically for each test file.

If there is a certain test where you want to use the real `monty-python` module, you can do so using `jest.requireActual`:

```js
const MockedMontyPython = require('./monty-python')

jest.mock('./monty-python', () => {
  return class MontyPython {
    getTheMeaningOfLife() {
      return 42
    }
  }
})

describe('MontyPython', () => {
  describe('getTheMeaningOfLife', () => {
    it('gets the mocked meaning of life', () => {
      const montyPython = new MockedMontyPython()
      expect(montyPython.getTheMeaningOfLife()).toBe(42)
    })

    it('gets the real meaning of life', () => {
      const RealMontyPython = jest.requireActual('./monty-python')
      const montyPython = new RealMontyPython()
      const mathRandomSpy = jest.spyOn(Math, 'random')
      mathRandomSpy.mockImplementation(() => 'Â¯\_(ãƒ„)_/Â¯')
      expect(montyPython.getTheMeaningOfLife()).toBe('Â¯\_(ãƒ„)_/Â¯')
      mathRandomSpy.mockRestore()
    })
  })
})
```

Alternatively you can use `jest.dontMock`, followed by a  regular `require` call:

```js
it('gets the real meaning of life', () => {
  jest.dontMock('./monty-python')
  const RealMontyPython = require('./monty-python')
  // ...
  jest.resetModules()
})
```

Lastly, passing the implementation to `jest.mock` is actually _optional_, I lied by omission! If you don't pass the implementation, the default behavior replaces all functions in that module with dummy mocks, which I don't find particularly useful, but things get more interesting when you add a `__mocks__` folder. ðŸ‘‡

### Mocking globally

Jest calls these "manual mocks". Personally, I use them rarely, but they're handy when you want to mock a certain module in multiple test files. You can create them by using the following file structure:

```
monty-python.js
__mocks__
â””â”€â”€ monty-python.js
```

You place a `__mocks__` folder right next to the module you're mocking, containing a file with the same name. If you're mocking a module in `node_modules` or a built-in module like `fs` or `path`, then add a `__mocks__` folder next to `node_modules`.

Now when you call `jest.mock('./monty-python')` without providing an implementation, Jest will use the manual mock, `__mocks__/monty-python.js`, as the implementation:

```js
module.exports = class MontyPython {
  getTheMeaningOfLife() {
    return 42
  }
}
```

Manul mocks for `node_modules` will be used **automatically**, even without calling `jest.mock` (this doesn't apply to built-in modules). Jest documentation presents this behavior as a feature, but I see it as a relic from their former behavior when they were automocking all modules by default.

You can always opt-out from manual mocks in lots of different ways, depending on what you need:

  1. by passing the implementation to `jest.mock`,

  2. by calling `jest.unmock` for modules like those in `node_modules` that would otherwise be mocked automatically,

  3. by calling `jest.requireActual` or `jest.dontMock`, if you need to use actual implementation only in particular tests, not the whole file etc.

## Conclusion

It took me a long time to understand the nuances of these features, how to get what I want and how to even _know_ what I want. I encourage you to scroll through the [`expect` reference](https://jestjs.io/docs/en/expect) and the [jest object reference](https://jestjs.io/docs/en/jest-object) to learn more about these features and how they compare to the ones that I didn't cover in this post. If you catch yourself making assertions on the `mock` property directly, try to see if there's already a built-in matcher for the assertion you're looking for, maybe also combining them with utilities like [`expect.objectContaining`](https://jestjs.io/docs/en/expect#expectobjectcontainingobject). This has the benefit of being more readable and having a better error message if your test fails.

I hope that this post brought you some clarity on the subject, have fun building better tests!
